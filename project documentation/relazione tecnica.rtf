{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Garamond;}{\f1\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs36\lang9 RELAZIONE TECNICA PER IL PROGETTO DI M.A.P.\par
\fs18 Spinosa Dario, Resta Fabio, Musacchio Elio\par

\pard\sa200\sl276\slmult1\fs22 Il seguente documento \'e8 una relazione dove si presenteranno le funzionalit\'e0 della nostra avventura testuale ("Uniba Crisis") spiegando eventuali decisioni prese dal punto di vista strutturale, come e perch\'e8 abbiamo adottato alcune soluzioni ed eventuali particolarit\'e0. La relazione sar\'e0 molto dettagliata e soprattutto si entrer\'e0 nello specifico delle soluzioni implementative scelte, questo perch\'e8 nelle slide dedicate alla presentazione abbiamo gi\'e0 realizzato un buon riassunto a livello di "cosa" fa il programma.\par
Il programma che abbiamo realizzato segue un design architetturale che abbiamo imparato durante il corso di Ingegneria del Software di questo semestre, ovvero l'ECB (Entity-Control-Boundary). Abbiamo infatti delle classi il cui scopo \'e8 mantenere informazioni, ovvero le Entity come ad esempio GenericObject, altre che gestiscono il programma, le Control come ActionsHandler, e infine quelle che si occupano della comunicazione con l'utente, le Boundary come AdventureGUI.\par
Abbiamo creato dei package dove abbiamo inserito le classi a seconda del loro compito. In questo modo, se si cercano classi che si occupano di qualcosa di specifico, si \'e8 subito in grado di capire dove esse si trovino. Parlando pi\'f9 in particolare delle singole classi, abbiamo cercato di crearne sempre di nuove ogni qual volta fosse stato necessario gestire o rappresentare qualcosa. In questo modo ci siamo assicurati che ogni classe non fosse coinvolta in troppe operazioni diverse tra loro e che avesse una responsabilit\'e0 ben definita. \par
Di seguito, elenchiamo e specifichiamo i package e le classi che esse contengono, soprattutto soffermandoci su quale responsabilit\'e0 esse abbiano nel programma.\par
\fs28 LoadingFile:\par
\fs22 Questo package contiene tutte le classi che si occupano di interagire in qualche modo con i file di gioco. Per rendere il programma pi\'f9 flessibile ed estendibile, abbiamo pensato di utilizzare la serializzazione degli oggetti, fornita da Java attraverso l'interfaccia Serializable, cos\'ec, invece di ricreare ogni volta l'essenziale per il gioco, questo si trova gi\'e0 su file e va semplicemente caricato quando inizia la partita.\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 FilesCreation: si occupa di creare gli oggetti e salvarli nei file. Avendo una classe predisposta a questo compito diventa anche molto facile aggiungere nuovi oggetti e, di conseguenza, modificare il gioco se necessario.\par
{\pntext\f1\'B7\tab}CombinationsFile, ObjectsFile, RoomFile: possiedono i metodi che permettono salvataggio e caricamento di, in ordine, lista delle combinazioni di oggetti, lista di oggetti nel gioco e mappa.\par

\pard\sa200\sl276\slmult1\fs32 Entities:\par
\fs22 Contiene tutte le classi Entity che hanno il compito di rappresentare una specifica entit\'e0 del nostro programma mantenendone le sue informazioni. Alcuni esempi importanti di queste classi nel nostro programma sono: Room, che contiene tutte le informazioni di una stanza, oppure GenericObject, che rappresenta un generico oggetto del gioco. La particolarit\'e0 pi\'f9 evidente \'e8 l'uso dell'ereditariet\'e0, che siamo riusciti ad applicare sia per GenericObject e GenericObjectContainer sia per Character, Npc e Protagonist.\par
Nel primo caso, abbiamo creato degli oggetti la cui funzione \'e8 contenerne degli altri (ad esempio una cassa); nel secondo caso, abbiamo creato una classe astratta Character da cui sia Npc sia Protagonist ereditano le caratteristiche essenziali di un generico personaggio. Cos\'ec facendo possiamo facilmente applicare il principio di sostituibilit\'e0 della programmazione Object Oriented ed usare istanze delle sottoclassi come se fossero della superclasse. Ad esempio,  dal momento che tutte le istanze di GenericObjectContainer sono istanze di GenericObject, nel nostro gioco possiamo creare un pacco o una scatola che possiamo anche aggiungere nel nostro inventario o addirittura in quello di un altro contenitore. Per quanto riguarda Character, invece, ci torna molto utile nel caso in cui volessimo aggiungere altre classi molto simili ad Npc e Protagonist. Ad esempio, in una prima versione del gioco avremmo dovuto avere anche un'altra classe per rappresentare i nemici. L'idea \'e8 stata poi scartata, tuttavia l'avere la classe Character permette di aggiungere facilmente alle stanze (che possono contenere delle istanze di questa) altri tipi di personaggi.\par
Infine, l'ereditariet\'e0 \'e8 stata usata estendendo GenericObject anche per le classi che implementano l'interfaccia Enigma. Cos\'ec facendo, un oggetto che rappresenta un enigma (come un pannello con delle leve) pu\'f2 essere trattato come una istanza di GenericObject ed \'e8 pi\'f9 facilmente trattabile.\par
Abbiamo, inoltre, delle strutture dati ovvero le classi Combinations e Prepositions, che hanno il compito di mantenere delle informazioni su dei collegamentri tra oggetti che esistono nel nostro programma. La prima ci serve a mantenere una lista di tutte le possibili combinazioni effettuabili fra coppie di GenericObject e cosa si ottiene unendoli; la seconda ci permette di collegare le preposizioni ai tipi di comandi  (ad esempio, nella frase "Combina [oggetto] da [oggetto]" \'e8 giusto utilizzare una preposizione ma non \'e8 quella corretta, la classe si occupa proprio di controllare queste possibilit\'e0). Per fare questo abbiamo utilizzato due Collections gi\'e0 esistenti, ovvero l'ArrayList e l'HashMap. Combinations \'e8 una ArrayList di una sua classe interna Node che contiene tre GenericObject (i due da combinare e il terzo che \'e8 ci\'f2 che si ottiene); Prepositions, invece, \'e8 una HashMap che ha come chiave una stringa (che rappresenta la preposizione) e come valore un Set di CommandType che \'e8 una classe enumerativa che rappresenta i possibili comandi del gioco. Entrambe le classi hanno poi dei metodi appositi per modificare tali Collections.\par
\fs28 Handlers:\par
\fs22 Contiene delle classi molto importanti per il corretto funzionamento del gioco. Nel nostro caso abbiamo soprattutto tre classi astratte: ActionsHandlerEssentials, GenericEventHandler e MessagesEssentials (le prime due Control e l'ultima Boundary). Fornendo una struttura essenziale per queste classi cos\'ec importanti, diventa molto facile sia aggiungere nuovi eventi al programma sia modificarlo alla base. Ad esempio, se creassimo un nuovo gioco con la stessa struttura di questo, queste tre classi sarebbero un ottimo punto di partenza, potremmo usare la stessa interfaccia e limitarci all'aggiungere nuovi ActionsHandler (per modificare i comandi e i loro effetti) e Messages (per modificare la lingua dei messaggi o aggiungerne di nuovi) ed aggiungere nuovi eventi estendendo GenericEventHandler.\par
Questo package contiene anche una classe Entity, ovvero Event, che abbiamo preferito tenere qui dal momento che si trovano anche le classi control che lavorano direttamente e solo su di essa.\par
\fs32 Main:\par
\fs22 Contiene la parte grafica del programma (ovvero l'interfaccia) e i due thread che abbiamo realizzato. Parlando dell'interfaccia, sono state create due classi che estendono JFrame, una per il men\'f9 principale ed una per la schermata di gioco vera e propria. Abbiamo poi aggiunto diversi componenti a questi JFrame e abbiamo anche creato delle classi che estendono JDialog da usare in combinazione con essi. Tutto questo \'e8 stato realizzato grazie all'utilizzo delle librerie Swing di Java che permettono di creare e gestire queste finestre. Abbiamo inoltre creato due classi che estendono la classe Thread: TimeThread e GameThread. Avendo deciso di creare un gioco a tempo avevamo bisogno di qualcosa nell'interfaccia che informasse il giocatore del suo scorrimento, abbiamo quindi realizzato un timer e un thread (TimeThread) che si occupa di aggiornarlo man mano che passa il tempo (il timer \'e8 semplicemente composto da delle JLabel e il thread si occupa di aggiornarle). GameThread invece \'e8 un thread di controllo che si occupa di verificare se il gioco \'e8 stato portato a termine dal giocatore oppure se sia scaduto il tempo. Controllando se il TimeThread \'e8 ancora in esecuzione oppure se il gioco non sia ancora stato completato \'e8 possibile ottenere queste informazioni. A seconda di ci\'f2 che poi avviene, il GameThread si occupa di mostrare una JDialog per la vittoria oppure una per la sconfitta.\par
\fs32 Parser:\par
\fs22 Contiene tutte le classi che sono necessarie affinch\'e8 il parser faccia il suo dovere, ovvero si occupi di analizzare le frasi prese in input dal giocatore e capire se queste abbiano senso o meno. Creer\'e0 un oggetto ParserOutput che, nel caso la frase abbia senso, conterr\'e0 tutte le informazioni utili ricavate dalla frase (ad esempio, gli oggetti o i personaggi con i quali il giocatore sta cercando di interagire), altrimenti questo non avr\'e0 alcun dato essenziale e sar\'e0 poi trattato come un comando non riconosciuto. In caso la frase sia sensata, l'oggetto ParserOutput sar\'e0 poi passato alla classe ActionsHandler che si occuper\'e0 di recuperare le informazioni da questo e, in caso sia possibile, effettuare l'azione desiderata dall'utente nel gioco.\par
Il Parser che abbiamo realizzato \'e8 in grado di capire la struttura di molte frasi in lingua italiana, anche grazie alla presenza di preposizioni, articoli e aggettivi, che rendono pi\'f9 semplice ed intuitiva la comunicazione con l'utente. In generale una qualsiasi frase che il parser riconoscer\'e0 come sensata deve:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Contenere un comando (ad esempio, Prendi, Lascia, ecc.);\fs32\par
{\pntext\f1\'B7\tab}\fs22 Non contenere pi\'f9 di due oggetti o pi\'f9 di un personaggio (per come \'e8 impostato il gioco queste frasi non avrebbero mai senso);\fs32\par
{\pntext\f1\'B7\tab}\fs22 Utilizzare attributi, preposizioni e aggettivi correttamente.\fs32\par

\pard\sa200\sl276\slmult1\fs22 Inoltre, abbiamo creato una classe astratta ParserEssentials ed una classe ItalianParser che la estende. In questo modo, se volessimo realizzare un parser che riconosce frasi in un'altra lingua, ad esempio l'inglese, ci baster\'e0 realizzare una nuova classe che estende ParserEssentials e al posto di utilizzare ItalianParser creare un'istanza di EnglishParser.\par
Infine, grazie all'utilizzo della classe AliasHandler (che si occupa di mantenere tutte le possibili stringhe con cui \'e8 possibile riferirsi a qualcosa) presente in entities, il Parser non sar\'e0 troppo legato ad uno specifico nome e potr\'e0 riconoscere oggetti, comandi o personaggi anche attraverso i loro alias. Questo rende pi\'f9 semplice e comodo per l'utente formulare frasi e meno frustrante l'esperienza di "comunicazione" con il nostro gioco.\par
\fs32 Resources:\par
\fs22 Contiene classi che contengono delle costanti di tipo String. Questo \'e8 stato fatto per semplificare operazioni come il modificare la lingua del gioco e dell'interfaccia. Se si volesse cambiare la lingua del gioco, invece di andare a cercare e modificare il valore di tutte le stringhe presenti nel codice, basterebbe semplicemente lavorare su queste costanti.\par
\par
In conclusione, abbiamo lavorato rispettando ed utilizzando a nostro vantaggio i principi della programmazione orientata agli oggetti (come l'ereditariet\'e0) che ci hanno permesso  di rendere il nostro codice molto estendibile e flessibile. Siamo anche soddisfatti di aver realizzato molte cose che abbiamo imparato durante il corso di Metodi Avanzati di Programmazione, tra queste l'uso dei file, la creazione di interfacce tramite Swing e un po' di programmazione concorrente con i due semplici thread utilizzati nel programma.\fs32\par
\fs22\par
}
 